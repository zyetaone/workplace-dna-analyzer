/**
 * Participant Remote Functions
 * Server-side operations for participant-related actions
 */

import { query, command } from '$app/server';
import * as v from 'valibot';
import { db } from '$lib/server/db';
import { sessions, participants } from '$lib/server/db/schema';
import { eq, and } from 'drizzle-orm';

// Load participant data for quiz
export const loadParticipantData = query(
	v.object({
		sessionSlug: v.string(),
		participantId: v.string()
	}),
	async ({ sessionSlug, participantId }) => {
		const [session] = await db
			.select()
			.from(sessions)
			.where(eq(sessions.slug, sessionSlug))
			.limit(1);
			
		if (!session) {
			throw new Error('Session not found');
		}
		
		const [participant] = await db
			.select()
			.from(participants)
			.where(
				and(
					eq(participants.id, participantId),
					eq(participants.sessionId, session.id)
				)
			)
			.limit(1);
			
		if (!participant) {
			throw new Error('Participant not found');
		}
		
		// Get questions based on config
		const questions = await import('$lib/questions').then(m => m.questions);
		
		return {
			session,
			participant,
			questions,
			sessionCode: session.code
		};
	}
);

// Save a quiz response
export const saveResponse = command(
	v.object({
		sessionSlug: v.string(),
		participantId: v.string(),
		questionIndex: v.number(),
		response: v.string(),
		generation: v.optional(v.string())
	}),
	async ({ sessionSlug, participantId, questionIndex, response, generation }) => {
		const [session] = await db
			.select()
			.from(sessions)
			.where(eq(sessions.slug, sessionSlug))
			.limit(1);
			
		if (!session) {
			throw new Error('Session not found');
		}
		
		const [participant] = await db
			.select()
			.from(participants)
			.where(
				and(
					eq(participants.id, participantId),
					eq(participants.sessionId, session.id)
				)
			)
			.limit(1);
			
		if (!participant) {
			throw new Error('Participant not found');
		}
		
		// Update responses
		const responses = participant.responses || {};
		responses[questionIndex] = response;
		
		// Update generation if it's the first question
		const updates: any = {
			responses,
			...(generation ? { generation } : {})
		};
		
		await db
			.update(participants)
			.set(updates)
			.where(eq(participants.id, participantId));
			
		return { success: true };
	}
);

// Complete the quiz
export const completeQuiz = command(
	v.object({
		sessionSlug: v.string(),
		participantId: v.string(),
		scores: v.object({
			collaboration: v.number(),
			formality: v.number(),
			tech: v.number(),
			wellness: v.number()
		})
	}),
	async ({ sessionSlug, participantId, scores }) => {
		await db
			.update(participants)
			.set({
				preferenceScores: scores,
				completed: true,
				completedAt: new Date().toISOString()
			} as any)
			.where(eq(participants.id, participantId));
			
		return {
			success: true,
			redirect: `/dashboard/${sessionSlug}/p/${participantId}/quiz/complete`
		};
	}
);

// Join session function for new participants
export const joinSession = command(
	v.object({
		sessionCode: v.string(),
		name: v.string()
	}),
	async ({ sessionCode, name }) => {
		// Find session by code
		const [session] = await db
			.select()
			.from(sessions)
			.where(eq(sessions.code, sessionCode))
			.limit(1);
		
		if (!session) {
			throw new Error('Invalid session code');
		}
		
		if (!session.isActive) {
			throw new Error('Session is not active');
		}
		
		// Create participant (ID auto-generated by database)
		const [participant] = await db
			.insert(participants)
			.values({
				sessionId: session.id,
				name
			})
			.returning();
		
		return {
			success: true,
			participant,
			sessionSlug: session.slug,
			redirect: `/dashboard/${session.slug}/p/${participant.id}/quiz`
		};
	}
);
